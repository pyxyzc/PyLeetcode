#include <bits/stdc++.h>

using namespace std;

// 魔法传送阵布局

// 魔法王国中有n个传送阵以树状结构相连。
// 魔女K小姐需要选择一个传送阵作为中心站，用来连接外界的魔力网络。
// 为了保证魔力传输的稳定性，她希望从中心站到其他所有传送阵的最大传送次数要最小。
// 请帮助她计算这个最小值。

// 例如，下面的传送阵网络结构（用ASCII表示）：
//     1
//    / \
//   2   3
//      / \
//     4   5
//    / \
//   6   7

// 当选择 3 号传送阵作为中心站时，到 1 号和 4 号传送阵需要传送 1 次，
// 到 2、5、6、7 号传送阵需要传送 2 次，因此最大传送次数为 2。

// 输入：
// 正整数n，表示传送阵的数量。
// 接下来n-1行，每行包括两个正整数，，表示两个传送阵之间存在直接连接。

// 输出：
// 输出一个正整数，表示从最优中心站到其他所有传送阵的最大传送次数的最小值。

// Example：
// 7
// 1 2
// 1 3
// 3 4
// 4 5
// 4 6
// 4 7

// 2

// 8
// 1 2
// 1 3
// 3 4
// 3 5
// 5 6
// 5 7
// 7 8

// 3

// 1<=n<=10^5

// Idea：

// 转化为求树的直径的一半（向上取整）。对于任意一棵树：
// 树的直径长度d是树中最长的简单路径长度
// 选择任意节点作为中心站，到其他节点的最大距离至少是d/2向上取整
// 一定存在一个节点，使得从它到其他所有节点的最大距离恰好是d/2向上取整

// 算法：
// 从任意节点开始dfs，找到最远的节点，同时记录每个节点的子树深度
// 在dfs过程中维护树的直径长度
// 最终答案就是直径长度除以2（向上取整）

int main()
{
    int n;
    cin >> n;
    vector<vector<int>> g(n + 1);

    for (int i = 1; i < n; i++) {
        int x, y;
        cin >> x >> y;
        g[x].push_back(y);
        g[y].push_back(x);
    }

    // 记录每个节点的子树深度
    vector<int> depth(n + 1, 0);
    int         d = 0;

    auto dfs = [&](auto&& dfs, int u, int pre) -> void {
        for (int v : g[u]) {
            if (v == pre) {
                continue;
            }

            // 继续向下遍历
            dfs(dfs, v, u);

            // 更新树的直径
            // depth[u] - 节点目前的最大子树深度
            // depth[v] - 子节点v的最大子树深度
            // depth[u] + depth[v] + 1 -
            // 从其他节点子树分支上来经过u再走v分支的可能的最大深度候选长度
            d = max(d, depth[u] + depth[v] + 1);

            // 更新当前节点的子最大树深度
            depth[u] = max(depth[u], depth[v] + 1);
        }
    };

    dfs(dfs, 1, -1);
    cout << ((d + 1) >> 1) << "\n";

    return 0;
}